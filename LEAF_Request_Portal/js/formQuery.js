/**
 * Form Query Helper
 */

var LeafFormQuery = function () {
  let query = {};
  let successCallback = null;
  let progressCallback = null;
  let rootURL = "";
  let useJSONP = false;
  let extraParams = "";

  clearTerms();

  /**
   * Reset search terms
   * @memberOf LeafFormQuery
   */
  function clearTerms() {
    query = {};
    query.terms = [];
    query.joins = [];
    query.sort = {};
    query.getData = [];
  }

  /**
   * Add a new search term
   * @param id - columnID
   * @param operator - SQL comparison operator
   * @param match - search term to match on
   * @param gate - AND or OR gate
   * @memberOf LeafFormQuery
   */
  function addTerm(id, operator, match, gate = "AND") {
    query.terms.push({id, operator, match, gate});
  }

  /**
   * Add a new search term for data table
   * @param id - columnID / 'data' to search data table / 'dependencyID' to search records_dependencies data, matching on 'filled'
   * @param indicatorID - indicatorID / dependencyID / "0" to search all indicators
   * @param operator - SQL comparison operator
   * @param match - search term to match on
   * @param gate - AND or OR gate
   * @memberOf LeafFormQuery
   */
  function addDataTerm(id, indicatorID, operator, match, gate = "AND") {
    query.terms.push({id, indicatorID, operator, match, gate});
  }

  /**
   * Import query generated by formSearch
   * @param object - The JSON query object generated by formSearch,
   * destructured array properties are terms, joins, getData.  getData renamed to avoid collision w class method
   * @memberOf LeafFormQuery
   */
  function importQuery({ terms = [], joins = [], getData: getIndData = [] } = {}) {
    //console.log('importQ input', 't', terms, 'j', joins, 'gd', getIndData)
    terms.forEach(t => {
      const {id, indicatorID, operator, match, gate} = t;
      //console.log('id:', id, 'ind:', indicatorID, 'op:', operator, 'm:', match, 'g:', gate)
      const numTermProperties = (Object.keys(t).length);
      switch (numTermProperties) {
        case 3:
          addTerm(id, operator, match);
          break;
        case 4:
          if (gate === undefined) {
            console.log('adding 4 param term, gate undef', t)
            addDataTerm(id, indicatorID, operator, match);
          } else {
            addTerm(id, operator, match, gate);
          }
          break;
        case 5:
          addDataTerm(id, indicatorID, operator, match, gate);
          break;
        default:
          console.log("Format error");
          break;
      }
    });
    joins.forEach(j => join(j));
    getIndData.forEach(ind => getData(ind));
  }

  /**
   * Limit number of results
   * @param offset / limit
   * @param limit (optional)
   * @memberOf LeafFormQuery
   */
  function setLimit(offset, limit) {
    if (limit === undefined) {
      query.limit = offset;
    } else {
      query.limit = limit;
      setLimitOffset(offset);
    }
  }

  /**
   * Limit number of results
   * @param offset
   * @memberOf LeafFormQuery
   */
  function setLimitOffset(offset) {
    query.limitOffset = offset;
  }

  /**
   * Join table
   * @param tableName
   * @memberOf LeafFormQuery
   */
  function join(tableName = '') {
    if (tableName !== '' && query.joins.indexOf(tableName) == -1) {
      query.joins.push(tableName);
    }
  }

  /**
   * Get data
   * @param string - indicatorID
   * @memberOf LeafFormQuery
   */
  function getData(indicatorID) {
    if (query.getData.indexOf(indicatorID) == -1) {
      query.getData.push(indicatorID);
    }
  }

  /**
   * Sort results
   * @param
   * @memberOf LeafFormQuery
   */
  function sort(column, direction) {
    query.sort.column = column;
    query.sort.direction = direction;
  }

  /**
   * Update an existing search term
   * @param id - columnID or "stepID"
   * @param operator - SQL comparison operator
   * @param match - search term to match on
   * @param gate - AND or OR gate
   * @memberOf LeafFormQuery
   */
  function updateTerm(id, operator, match, gate = "AND") {
    for (let i in query.terms) {
      if (query.terms[i].id == id && query.terms[i].operator == operator) {
        query.terms[i].match = match;
        query.terms[i].gate = gate;
        return;
      }
    }
    addTerm(id, operator, match, gate);
  }

  /**
   * Update an existing data search term
   * @param id - columnID / 'data' to search data table / 'dependencyID' to search records_dependencies data, matching on 'filled'
   * @param indicatorID - indicatorID / dependencyID
   * @param operator - SQL comparison operator
   * @param match - search term to match on
   * @param gate - AND or OR gate
   * @memberOf LeafFormQuery
   */
  function updateDataTerm(id, indicatorID, operator, match, gate = "AND") {
    for (let i in query.terms) {
      if (
        query.terms[i].id == id &&
        query.terms[i].indicatorID == indicatorID &&
        query.terms[i].operator == operator
      ) {
        query.terms[i].match = match;
        query.terms[i].gate = gate;
        return;
      }
    }
    addDataTerm(id, indicatorID, operator, match, gate);
  }

  /**
   * Add extra parameters to the end of the query API URL
   * @param string params
   */
  function setExtraParams(params = "") {
    extraParams = params;
  }

  /**
   * @param funct - Success callback (see format for jquery ajax success)
   * @memberOf LeafFormQuery
   */
  function onSuccess(funct) {
    successCallback = funct;
  }

  /**
   * onProgress assigns a callback to be called on every getBulkData() iteration
   * @param funct - funct(int Progress). Progress is the number of records that have been processed
   * @memberOf LeafFormQuery
   */
  function onProgress(funct) {
    progressCallback = funct;
  }

  /**
   * Execute search query in chunks
   * @param limitOffset Used in subsequent recursive calls to track current offset
   * @returns Promise resolving to query response
   * @memberOf LeafFormQuery
   */
  let results = {};
  let batchSize = 500;
  function getBulkData(limitOffset = 0) {
    if (limitOffset == 0) {
      results = {};
    }
    limitOffset = parseInt(limitOffset);

    query.limit = batchSize;
    query.limitOffset = limitOffset;

    let el = document.createElement("div");
    el.innerHTML = JSON.stringify(query);

    const queryUrl = el.innerText;
    const dataType = useJSONP ? "jsonp" : "json";
    const urlParamJSONP = useJSONP ? "&format=jsonp" : "";
    return $.ajax({
      type: "GET",
      url: `${rootURL}api/form/query?q=${queryUrl + extraParams + urlParamJSONP}`,
      dataType: dataType,
    }).then(function (res, resStatus, resJqXHR) {
      results = Object.assign(results, res);

      if (
        Object.keys(res).length == batchSize ||
        resJqXHR.getResponseHeader("leaf-query") == "continue"
      ) {
        let newOffset = limitOffset + batchSize;
        if (typeof progressCallback == "function") {
          progressCallback(newOffset);
        }
        return getBulkData(newOffset);
      } else {
        if (typeof successCallback == "function") {
          successCallback(results, resStatus, resJqXHR);
        }
        return results;
      }
    });
  }

  /**
   * Execute search query
   * @returns $.ajax() object
   * @memberOf LeafFormQuery
   */
  function execute() {
    if (query.getData != undefined && query.getData.length == 0) {
      delete query.getData;
    }
    if (query.limit == undefined || isNaN(query.limit) || parseInt(query.limit) > 9999) {
      return getBulkData();
    }

    let el = document.createElement("div");
    el.innerHTML = JSON.stringify(query);
    
    const queryUrl = el.innerText;
    const dataType = useJSONP ? "jsonp" : "json";
    const urlParamJSONP = useJSONP ? "&format=jsonp" : "";
    return $.ajax({
      type: "GET",
      url: `${rootURL}api/form/query?q=${queryUrl + extraParams + urlParamJSONP}`,
      dataType: dataType,
      success: successCallback,
    });
  }

  return {
    clearTerms,
    addTerm,
    addDataTerm,
    importQuery,
    getQuery: () => query,
    getData,
    updateTerm,
    updateDataTerm,
    setQuery: (inc) => query = inc,
    setLimit,
    setLimitOffset,
    setRootURL: (url) => rootURL = url,
    getRootURL: () => rootURL,
    useJSONP: (state) => useJSONP = state,
    setExtraParams,
    join,
    sort,
    onSuccess,
    onProgress,
    execute
  };
};
